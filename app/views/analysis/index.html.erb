<meta name="turbo-visit-control" content="reload">

<div class="analysis-container">
  <h1>DriveCam Gas Card Analysis</h1>

  <!-- File Upload Form -->
  <%= form_with url: "/analysis/import", local: true, html: { multipart: true } do |f| %>
    <%= f.file_field :file, style: "display:none", onchange: "this.form.submit();" %>
    <button type="button" onclick="this.previousElementSibling.click()">Upload File</button>
  <% end %>

  <% if session[:gas_file_path].present? %>
    <p>File uploaded successfully. Ready to analyze.</p>
    <%= form_with url: "/analysis/run", method: :post, local: true do |f| %>
      <%= hidden_field_tag :sync, 1 %>
    
      <label>Row Limit:</label>
      <%= f.number_field :row_limit, min: 1, step: 1 %>
    
      <label>Starting Row:</label>
      <p> (Row 2 is first row) </p>
      <%= f.number_field :row_offset, value: 2, min: 2, step: 1 %>
    
      <%= f.submit "Analyze" %>
    <% end %>
    
  <% end %>

  <button onclick="stopAnalysis()">Stop</button>

  <p id="report-download" style="display:none;">
    <a href="/analysis/report" class="button">Download Report</a>
    <span id="report-name" style="margin-left: 10px; color: gray;"></span>
  </p>


  <div id="progress-container" style="width: 100%; background: #eee; margin: 10px 0;">
    <div id="progress-bar" style="width: 0%; height: 20px; background: green;"></div>
  </div>
  <p id="progress-text"></p>


  <hr style="margin: 50px 0;">

</div>

<script>

function stopAnalysis() {
  fetch('/analysis/stop', { method: 'POST' })
    .then(res => res.json())
    .then(data => {
      alert(data.message);
      document.getElementById('progress-text').textContent = "Analysis stopped.";
    });
}

window.analysisState = window.analysisState || { lastProgress: 0, analysisStartTime: null, polling: false };

function pollProgress() {
  const state = window.analysisState;
  if (!state.analysisStartTime) {
    state.analysisStartTime = Date.now(); // set start time on first call
  }
  fetch('/analysis/progress')
    .then(res => res.json())
    .then(data => {
      if (!data.total || data.total === 0) return;

      const bar = document.getElementById('progress-bar');
      const text = document.getElementById('progress-text');

      let percent = (data.current / data.total) * 100;
      bar.style.width = percent + '%'; // <--- ADD THIS

      // Calculate elapsed time
      let elapsedMs = Date.now() - window.analysisState.analysisStartTime;
      let elapsedSec = Math.floor(elapsedMs / 1000);
      let hours = Math.floor(elapsedSec / 3600);
      let minutes = Math.floor((elapsedSec % 3600) / 60);
      let seconds = elapsedSec % 60;

      // Format as hh:mm:ss or mm:ss
      let timeString = hours > 0
        ? `${hours}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`
        : `${minutes}:${seconds.toString().padStart(2, '0')}`;

      text.textContent = `Processing row ${data.current} of ${data.total} (${percent.toFixed(1)}%) — Elapsed: ${timeString}`;

      if (data.report_ready) {
        document.getElementById('report-download').style.display = 'block';
        document.getElementById('report-name').textContent = `(${data.report_name})`;
      }

      // Stop polling if stopped or error
      if (data.stopped || data.error) {
        let msg = data.error
          ? "Analysis failed. Partial report generated."
          : "Analysis stopped.";
        if (data.last_row) {
          msg += ` — Last processed row: ${data.last_row}. Restart from this row.`;
          if (data.last_row !== undefined && data.last_row !== null) {
            const offsetInput = document.querySelector('input[name="row_offset"]');
            if (offsetInput) {
              offsetInput.value = data.last_row; // auto-fill resume row
            }
          }
        }
        text.textContent = msg;
        window.analysisState.polling = false;
        return; // Exit polling
      }

      // Continue polling
      if (data.current < data.total) {
        const changed = data.current !== window.analysisState.lastProgress;
        window.analysisState.lastProgress = data.current;
        const delay = changed ? 1000 : 2000;
        if (window.analysisState.polling) setTimeout(pollProgress, delay);
      }
    });
}

// Reset timer when analysis starts (bind once)
document.addEventListener('turbo:load', () => {
  const analyzeForm = document.querySelector('form[action="/analysis/run"]');
  if (!analyzeForm) return;
  if (window.analysisBound) return; // prevent duplicate listeners after Turbo renders
  window.analysisBound = true;

  analyzeForm.addEventListener('submit', () => {
    window.analysisState.lastProgress = 0;
    window.analysisState.analysisStartTime = null;
    window.analysisState.polling = true;
    setTimeout(pollProgress, 2000);
  });
});




</script>