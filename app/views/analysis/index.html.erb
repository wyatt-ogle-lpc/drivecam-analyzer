<meta name="turbo-visit-control" content="reload">

<div class="analysis-container">
  <h1>DriveCam Gas Card Analysis</h1>

  <!-- File Upload Form -->
  <%= form_with url: "/analysis/import", local: true, html: { multipart: true } do |f| %>
    <%= f.file_field :file, id: "upload-file-input", style: "display:none" %>
    <button type="button" id="upload-file-button">Upload File</button>    
  <% end %>

  <% if session[:gas_file_path].present? %>
    <p>File uploaded successfully. Ready to analyze.</p>
    <%= form_with url: "/analysis/run", method: :post, local: true do |f| %>
      <%= hidden_field_tag :sync, 1 %>
    
      <label>Row Limit:</label>
      <%= f.number_field :row_limit, min: 1, step: 1 %>
    
      <label>Starting Row:</label>
      <p> (Row 2 is first row) </p>
      <%= f.number_field :row_offset, value: 2, min: 2, step: 1 %>
    
      <%= f.submit "Analyze" %>
    <% end %>
    
  <% end %>

  <button onclick="stopAnalysis()">Stop</button>

  <p id="report-download" style="display:none;">
    <a href="/analysis/report" class="button">Download Report</a>
    <span id="report-name" style="margin-left: 10px; color: gray;"></span>
  </p>


  <div id="progress-container" style="width: 100%; background: #eee; margin: 10px 0;">
    <div id="progress-bar" style="width: 0%; height: 20px; background: green;"></div>
  </div>
  <p id="progress-text"></p>


  <hr style="margin: 50px 0;">

</div>

<script nonce="<%= content_security_policy_nonce %>">

function stopAnalysis() {
  fetch('/analysis/stop', { method: 'POST' })
    .then(res => res.json())
    .then(data => {
      alert(data.message);
      document.getElementById('progress-text').textContent = "Analysis stopped.";
    });
}

// Bind upload button & file input (replaces inline onclick/onchange)
document.addEventListener('turbo:load', () => {
  const uploadBtn = document.getElementById('upload-file-button');
  const uploadInput = document.getElementById('upload-file-input');
  if (uploadBtn && uploadInput) {
    uploadBtn.addEventListener('click', () => uploadInput.click());
    uploadInput.addEventListener('change', () => { if (uploadInput.form) uploadInput.form.submit(); });
  }
});


window.analysisState = window.analysisState || { lastProgress: 0, analysisStartTime: null, polling: false };

function pollProgress() {
  const state = window.analysisState;
  if (!state.analysisStartTime) {
    state.analysisStartTime = Date.now(); // set start time on first call
  }
  fetch('/analysis/progress')
    .then(res => res.json())
    .then(data => {
      if (!data || !('total' in data) || data.total === 0) {
        if (window.analysisState.polling) setTimeout(pollProgress, 2000);
        return;
      }
    

      const bar = document.getElementById('progress-bar');
      const text = document.getElementById('progress-text');

      let percent = (data.current / data.total) * 100;
      bar.style.width = percent + '%'; // <--- ADD THIS

      // Calculate elapsed time
      let elapsedMs = Date.now() - window.analysisState.analysisStartTime;
      let elapsedSec = Math.floor(elapsedMs / 1000);
      let hours = Math.floor(elapsedSec / 3600);
      let minutes = Math.floor((elapsedSec % 3600) / 60);
      let seconds = elapsedSec % 60;

      // Format as hh:mm:ss or mm:ss
      let timeString = hours > 0
        ? `${hours}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`
        : `${minutes}:${seconds.toString().padStart(2, '0')}`;

      text.textContent = `Processing row ${data.current} of ${data.total} (${percent.toFixed(1)}%) — Elapsed: ${timeString}`;

      if (data.report_ready) {
        document.getElementById('report-download').style.display = 'block';
        document.getElementById('report-name').textContent = `(${data.report_name})`;
      }

      // Stop polling if stopped or error
      if (data.stopped || data.error) {
        let msg = data.error
          ? "Analysis failed. Partial report generated."
          : "Analysis stopped.";
        if (data.last_row) {
          msg += ` — Last processed row: ${data.last_row}. Restart from this row.`;
          if (data.last_row !== undefined && data.last_row !== null) {
            const offsetInput = document.querySelector('input[name="row_offset"]');
            if (offsetInput) {
              offsetInput.value = data.last_row; // auto-fill resume row
            }
          }
        }
        text.textContent = msg;
        window.analysisState.polling = false;
        return; // Exit polling
      }

      // Continue polling
      if (data.current < data.total) {
        const changed = data.current !== window.analysisState.lastProgress;
        window.analysisState.lastProgress = data.current;
        const delay = changed ? 1000 : 2000;
        if (window.analysisState.polling) setTimeout(pollProgress, delay);
      }
    });
}

// Reset timer when analysis starts (bind once)
document.addEventListener('turbo:load', () => {
  // Always try to (re)start polling after load; it will self-throttle if nothing is running
  if (!window.analysisState) window.analysisState = { lastProgress: 0, analysisStartTime: null, polling: false };
  if (!window.analysisState.polling) {
    window.analysisState.polling = true;
    setTimeout(pollProgress, 1000);
  }

  // Bind once to the Analyze form to reset timers and start polling immediately on submit
  const analyzeForm = document.querySelector('form[action="/analysis/run"]');
  if (analyzeForm && !window.analysisBound) {
    window.analysisBound = true;
    analyzeForm.addEventListener('submit', () => {
      window.analysisState.lastProgress = 0;
      window.analysisState.analysisStartTime = null;
      window.analysisState.polling = true;
      setTimeout(pollProgress, 2000);
    });
  }
});





</script>